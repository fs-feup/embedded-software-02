#platform "gen4-uLCD-43D"

#inherit "4DGL_16bitColours.fnc"

#inherit "GeneratedConsts.inc"
#inherit "Strings.inc"
#inherit "UpdateDigits.inc"

#CONST
    EnablePin   PA4
    ClockPin    PA8
    SDIPin      PA11 
    SDOPin      PA6

    FORM_FSFEUP     0
    FORM_PAGE_ONE   1
    FORM_PAGE_TWO   2
    FORM_PAGE_THREE 3
    
    // Widget IDs
    WIDGET_FORM_CMD 0x9999
    WIDGET_THROTTLE    0x0001
    WIDGET_BRAKE 0x0002
    WIDGET_SPEED 0x0003
    WIDGET_INVERTER_MODE 0x0004
    WIDGET_CELLS_MIN 0x0005
    WIDGET_CELLS_MAX 0x0006
    WIDGET_SOC 0x0007
    WIDGET_INVERTER_ERRORS 0x000C
    WIDGET_INVERTER_WARNINGS 0x000D
    WIDGET_MISSION 0x000E
#END


// IMPORTANT MAYBE: A var is a 16-bit signed integer with a range of -32768 to 32767
var current_form := 0;

var lastInverterValue := 0;
var lastMissionValue := 0;
var lastThrottleValue := -1;
var lastBrakeValue := -1;
var lastSpeedValue := 0;
var lastCellsMinValue := 0;
var lastCellsMaxValue := 0;
var lastSOCValue := 0;
var lastInverterErrors := 0;
var lastInverterWarnings := 0;

var ledErrMap[14] := [iLedA0, iLedA1, iLedA2, iLedA3, iLedA4, iLedA5, iLedA6, iLedA7, iLedA8, iLedA9, iLedA10, iLedA11, iLedA16, iLedA17];
var ledWarnMap[14] := [iLedA19, iLedA20, iLedA21, iLedA22, iLedA23, iLedA24, iLedA25, iLedA26, iLedA27, iLedA28, iLedA29, iLedA30, iLedA31, iLedA32];


func main()
    
    gfx_Set(SCREEN_MODE, DEFAULT_ORIENTATION);
    
    SetupMedia();

    var err;

    pin_Set(PIN_OUT,EnablePin);
    pin_HI(EnablePin);

    if (! SPI1_SDI_pin(SDIPin))
        print("SDI Pin Invalid\n") ;
        err := 1 ;
    endif

    if (! SPI1_SCK_pin(ClockPin))
        print("SCK Pin Invalid\n") ;
        err := 1 ;
    endif

    if (! SPI1_SDO_pin(SDOPin))
        print("SDO Pin Invalid\n") ;
        err := 1 ;
    endif

    if (! SPI1_Init(SPI_SPEED15, SPI16_MODE_0, EnablePin))
        print("INIT parameter Invalid\n") ;
        err := 1 ;
    endif

    if(err)
        repeat forever
    endif


    form_FS(); // show FSFEUP logo initially...    

    // when done switch to widgets
    widgets_page_one();
    
    var queues;
    var state := 0;
    repeat
        queues := events();
        state:= !state;
        img_Show(hndl, iLedA18); // show LedA18, only do this once
        img_SetWord(hndl, iLedA18, IMAGE_INDEX, state); // where state is 0 (OFF) or 1 (ON)
        img_Show(hndl, iLedA18);

        // Allow time for slave to queue new values
        //if (queues == 0) 
        pause(20);
        //endif 
    forever
endfunc

func getInverterMode(var modeValue)
    var modeStr;
    switch (modeValue) 
        case 0:
            modeStr := "INVERTER:\nSCRUT";
            break;
        case 1:
            modeStr := "INVERTER:\nCRUISING";
            break;
        case 2:
            modeStr := "INVERTER:\nAS ACCEL";
            break;
        case 3:
            modeStr := "INVERTER:\nSKIDPAD ";
            break;
        case 4:
            modeStr := "INVERTER:\nENDURANCE ";
            break;
        case 5:
            modeStr := "INVERTER:\nAUTOCROSS ";
            break;
        case 6:
            modeStr := "INVERTER:\nACCEL";
            break;
        case 7:
            modeStr := "INVERTER:\nMAX ACCEL";
            break;
        default:
            modeStr := "INVERTER:\nUNKNOWN";
            break;
    endswitch
    return modeStr;
endfunc

func getMission(var missionValue)
    var missionStr;
    switch (missionValue) 
        case 0:
            missionStr := "MISSION:\nMANUAL";
            break;
        case 1:
            missionStr := "MISSION:\nACCELERATION";
            break;
        case 2:
            missionStr := "MISSION:\nSKIDPAD";
            break;
        case 3:
            missionStr := "MISSION:\nAUTOCROSS";
            break;
        case 4:
            missionStr := "MISSION:\nTRACKDRIVE";
            break;
        case 5:
            missionStr := "MISSION:\nEBS_TEST";
            break;
        case 6:
            missionStr := "MISSION:\nINSPECTION";
            break;
        case 7:
            missionStr := "MISSION:\nCHUCK";
            break;
        default:
            missionStr := "MISSION:\nUNKNOWN";
            break;
    endswitch
    return missionStr;
endfunc

// -------------------------
// ------- FORMS -----------

func form_FS()    
    
    img_Show(hndl, iImage2); // show Image2, only do this once
    img_Show(hndl, iGaugeA0); // show GaugeA0, only do this once

    var x := 0;
    while (x != 200)
        img_SetWord(hndl, iGaugeA0, IMAGE_INDEX, x); // where value is 0 to 50
        img_Show(hndl, iGaugeA0);
        x++;
        pause(5);
    wend
endfunc


func widgets_page_one()
    current_form := 1;
    
    gfx_BGcolour(0x0000);
    gfx_Cls();

    // THROTTLE LABEL
    img_Show(hndl, iLabel0); // show Label0, only do this once    
    // THROTTLE %
    img_Show(hndl, iGaugeC0); // show GaugeC0, only do this once

    // BRAKE LABEL
    img_Show(hndl, iLabel4); // show Label4, only do this once
    // BRAKE
    img_Show(hndl, iGaugeC1); // show GaugeC1, only do this once


    
    //Speed label
    img_Show(hndl, iLabel5); // show Label5, only do this once

    // Speed    
    img_Show(hndl, iTextDigits3); // show digits background, only do this once


    // Cells Label
    img_Show(hndl, iLabel1); // show Label1, only do this once
    
    // Cells Max
    img_Show(hndl, iLabel2); // show Label2, only do this once
    img_Show(hndl, iTextDigits1); // show digits background, only do this once

    // Cells Min
    img_Show(hndl, iLabel3); // show Label3, only do this once
    img_Show(hndl, iTextDigits2); // show digits background, only do this once

    // SOC Label
    img_Show(hndl, iLabel6); // show Label6, only do this once
    img_Show(hndl, iTextDigits4); // show digits background, only do this once

    // Inverter Mode
    writeStrings(Strings0Info, getInverterMode(lastInverterValue));           // where txt is a var buffer or a static string

    // Mission 
    writeStrings(Strings1Info, getMission(lastMissionValue));           // where txt is a var buffer or a static string


    updateDigits(hndl, iTextDigits3, TextDigits3Info, lastSpeedValue);
    updateDigits(hndl, iTextDigits2, TextDigits2Info, lastCellsMinValue);
    updateDigits(hndl, iTextDigits1, TextDigits1Info, lastCellsMaxValue);
    updateDigits(hndl, iTextDigits4, TextDigits4Info, lastSOCValue);

endfunc

func widgets_page_two()
    current_form := 2;
     // background
    img_Show(hndl, iForm4);

    
    img_Show(hndl, iLabel7);
    img_Show(hndl, iLabel8);

    img_Show(hndl, iLedA0);
    img_Show(hndl, iLedA1);
    img_Show(hndl, iLedA2);
    img_Show(hndl, iLedA3);
    img_Show(hndl, iLedA4);
    img_Show(hndl, iLedA5);
    img_Show(hndl, iLedA6);
    img_Show(hndl, iLedA7);
    img_Show(hndl, iLedA8);
    img_Show(hndl, iLedA9);
    img_Show(hndl, iLedA10);
    img_Show(hndl, iLedA11);
    img_Show(hndl, iLedA16);
    img_Show(hndl, iLedA17);


endfunc

func widgets_page_three()
    current_form := 3;    
    img_Show(hndl, iForm5);

    img_Show(hndl, iLabel9);
    img_Show(hndl, iLabel10);

    img_Show(hndl, iLedA19);
    img_Show(hndl, iLedA20);
    img_Show(hndl, iLedA21);
    img_Show(hndl, iLedA22);
    img_Show(hndl, iLedA23);
    img_Show(hndl, iLedA24);
    img_Show(hndl, iLedA25);
    img_Show(hndl, iLedA26);
    img_Show(hndl, iLedA27);
    img_Show(hndl, iLedA28);
    img_Show(hndl, iLedA29);
    img_Show(hndl, iLedA30);
    img_Show(hndl, iLedA31);
    img_Show(hndl, iLedA32);
endfunc

func switch_form(var formPage)
    if (formPage == 0x0001) widgets_page_one();
    if (formPage == 0x0002) widgets_page_two();
    if (formPage == 0x0003) widgets_page_three();
endfunc

// -----------------------
// -------- WIDGETS ------

func updateWidgets(var widgetID, var value)
    var new_val := 1;
    var bitIndex := 0;
    var i;
    var ledState;
    if (widgetID == WIDGET_THROTTLE && value != lastThrottleValue)
        lastThrottleValue := value;
        img_SetWord(hndl, iGaugeC0, IMAGE_INDEX, value);
    else if (widgetID == WIDGET_BRAKE && value != lastBrakeValue)
        lastBrakeValue := value;
        img_SetWord(hndl, iGaugeC1, IMAGE_INDEX, value);
    else if (widgetID == WIDGET_SPEED && value  != lastSpeedValue)
        lastSpeedValue := value;        
    else if (widgetID == WIDGET_INVERTER_MODE && value != lastInverterValue)
        lastInverterValue := value;
    else if (widgetID == WIDGET_MISSION && value != lastMissionValue)
        lastMissionValue := value;
    else if (widgetID == WIDGET_CELLS_MIN && value != lastCellsMinValue)
        lastCellsMinValue := value;
    else if (widgetID == WIDGET_CELLS_MAX && value != lastCellsMaxValue)
        lastCellsMaxValue := value;
    else if (widgetID == WIDGET_SOC && value != lastSOCValue)
        lastSOCValue := value;
    else if (widgetID == WIDGET_INVERTER_ERRORS && value != lastInverterErrors)
        lastInverterErrors := value;
        bitIndex := 0;
        for (i := 0; i < 16; i++)
            if (i == 13 || i == 14) continue;
            ledState := (value >> i) & 1;
            if (ledState)
                img_SetWord(hndl, ledErrMap[bitIndex], IMAGE_INDEX, 1);
            else
                img_SetWord(hndl, ledErrMap[bitIndex], IMAGE_INDEX, 0);
            endif
            bitIndex++;
        next
    else if (widgetID == WIDGET_INVERTER_WARNINGS && value != lastInverterWarnings)
        lastInverterWarnings := value;
        bitIndex := 0;
        for (i := 0; i < 16; i++)
            if (i == 13 || i == 14) continue;
            ledState := (value >> i) & 1;
            if (ledState)
                img_SetWord(hndl, ledWarnMap[bitIndex], IMAGE_INDEX, 1);
            else
                img_SetWord(hndl, ledWarnMap[bitIndex], IMAGE_INDEX, 0);
            endif
            bitIndex++;
        next
    else
        new_val := 0;
    endif
    return new_val;
endfunc

func showWidget(var widgetID)
    var bitIndex := 0;
    var i;
    if (current_form == 1) 
        if (widgetID == WIDGET_THROTTLE)
            img_Show(hndl, iGaugeC0);
        else if (widgetID == WIDGET_BRAKE)
            img_Show(hndl, iGaugeC1);
        else if (widgetID == WIDGET_SPEED)
            updateDigits(hndl, iTextDigits3, TextDigits3Info, lastSpeedValue);
        else if (widgetID == WIDGET_INVERTER_MODE)
            img_Show(hndl, iPanelA0); // show PanelA0, only do this once
            writeStrings(Strings0Info, getInverterMode(lastInverterValue));
        else if (widgetID == WIDGET_MISSION)
            img_Show(hndl, iPanelA1);
            writeStrings(Strings1Info, getMission(lastMissionValue));
        else if (widgetID == WIDGET_CELLS_MIN)
            updateDigits(hndl, iTextDigits2, TextDigits2Info, lastCellsMinValue);
        else if (widgetID == WIDGET_CELLS_MAX)
            updateDigits(hndl, iTextDigits1, TextDigits1Info, lastCellsMaxValue);
        else if (widgetID == WIDGET_SOC)
            updateDigits(hndl, iTextDigits4, TextDigits4Info, lastSOCValue);

        endif
    else if (current_form == 2)
        if (widgetID == WIDGET_INVERTER_ERRORS) 
            bitIndex := 0;
            for (i := 0; i < 16; i++)
                if (i == 13 || i == 14) continue; // skip unused bits
                img_Show(hndl, ledErrMap[bitIndex]); // Show the LED
                bitIndex++;
            next
        endif
    else if (current_form == 3)
        if (widgetID == WIDGET_INVERTER_WARNINGS) 
            bitIndex := 0;
            for (i := 0; i < 16; i++)
                if (i == 13 || i == 14) continue; // skip unused bits
                img_Show(hndl, ledWarnMap[bitIndex]); // Show the LED
                bitIndex++;
            next
        endif
    endif
endfunc

func events()
    var r;
    var queues := 0;
    var success := 0;

    var widgetID := 0, widgetValue := 0;
    //var private successCount := 0;

    pin_LO(EnablePin); // Assert

    //putstr("\nSTART: ");
    r := SPI1_Write(0xFEED);
    //print([HEX4] r, " \nQ: ");

    var n;
    for (n := 0; n < 20; n++)
        r := SPI1_Read();
        //print([HEX4] r, " ");
        if (HIbyte(r) == HIbyte(0x6900))
            queues := LObyte(r);
            //print("\nQ ", queues);
            break;
        endif
    next

    r := 0;
    if (queues > 0)
        for (n := 0; n < 20; n++)
            //putstr("\n");
            if (r == 0xD632) break;
            //putstr("WAIT: ");
            r := SPI1_Write(0xF00D);
            //print([HEX4] r, " ");
            if (r == 0xDA7A)
                var buf[15];
                var pos := 0;
                var checksum := 0xDA7A;
                buf[pos] := 0xDA7A; 
                pos++;

                //putstr("\n DATA: ");
                buf[pos] := SPI1_Write(0xF00D);
                checksum ^= buf[pos];
                //print([HEX4] buf[pos], " ");
                pos++;

                var j;
                for (j := 0; j < buf[1]; j++)
                    buf[pos] := SPI1_Write(0xF00D);
                    //print([HEX4] buf[pos], " ");
                    if (pos < buf[1] - 1) checksum ^= buf[pos];
                    pos++;
                    if (pos >= buf[1])
                        //putstr("END ");
                        if (checksum == buf[buf[1]-1])

                            //var d;
                            //for (d := 4; d < buf[1] - 1; d++) // Skip checksum
                            //    print([HEX4] buf[d], " ");
                            //next

                            var data := 0;
                            var k;
                            var flag := 0;
                            for (k := 0; k < 20; k++)
                                data := SPI1_Write(0xCE0A);
                                //print([HEX4] data, " ");
                                if (data == 0xD632) 
                                    queues--;
                                    //print(successCount++);
                                    //flag := 1;
                                    widgetID := buf[2];
                                    widgetValue := buf[4];
                                    success := 1;
                                    break;
                                endif
                            next
                            //if (flag == 0) putstr("ERR_END ");
                            break;
                        endif
                        //putstr("ERR_CHECK ");
                        break;
                    endif
                next
            endif
        next
    else
        //putstr("UNAVAIL\n");
    endif
    
    pin_HI(EnablePin); // Deassert

    if (success) 
        var changed;
        if (widgetID == 0x9999) 
            switch_form(widgetValue);
        else
            changed := updateWidgets(widgetID, widgetValue);
            if (changed) showWidget(widgetID);
        endif
        
    endif
    return queues;
endfunc